;;; html-prep.ss
;;; Copyright (c) 1998 Cadence Research Systems

;;; authors: R. Kent Dybvig and Oscar Waddell

;;; TODO
;;; - move stuff now unique to html-prep.ss from preplib.ss
;;; - update documentation

;;; primitive commands (latex standard first, then extensions)
;;;   ~
;;;   \'e, \'o
;;;   \"{<letter>}
;;;   \c{<letter>}
;;;   \\
;;;   $ ... $                                 (see below)
;;;   { ... }                                 (groups)
;;;   \begingroup ... \endgroup
;;;   \bgroup ... \egroup
;;;   %<comment>
;;;   \[ ... \]                               (see below)
;;;   \begin{eqnarray*} ... \end{eqnarray*}   (see below)
;;;   \begin{divertoutput}[i] ... \end{divertoutput}
;;;      i selects a currently opened file:
;;;          0 first file opened, 1 second file, ...
;;;          or -1 most recent, -2 next most recent, ...
;;;   \bf
;;;   \bibitem
;;;   \cite{...}
;;;   \emph{...}
;;;   \epsfbox{...}
;;;   \genlab
;;;   \hindex{label}{stuff}                   (see below)
;;;   \include{filename}
;;;   \index{stuff}                           (see below)
;;;   \label{...}
;;;   \pagebreak[n]
;;;   \pageref{...}
;;;   \ref{...}
;;;   \vskip                                  (remainder of line ignored!)
;;;   \def
;;;   \newenvironment
;;;   \renewenvironment
;;;   \newif
;;;   \newcounter
;;;   \setcounter
;;;   \addtocounter
;;;   \stepcounter
;;;   \tt

;;;   \closehtmlfile
;;;   \currentoutputfile
;;;   \documenttitle[formats]{title}
;;;   \hpageref{label}{text}                  (pageref link around text)
;;;   \href{label}{text}                      (ref link around text)
;;;   \hardspaces
;;;   \makeindex
;;;   \openhtmlfile
;;;   \raw{...}

;;; Within $ ... $, \[ ... \], \begin{eqnarray*} ... \end{eqnarray*}
;;;   user-defined macros are not presently expanded

;;; \index and \hindex syntax
;;;   \index{levels} or \index{levels|pageformat}
;;;   \hindex{label}{levels} or \hindex{label}{levels|pageformat}
;;;   levels --> level
;;;          --> level!levels
;;;   level  --> keyentry                     (key and entry same)
;;;   level  --> key@entry                    (separate key and entry)

;;;   index and hindex entries follow makeindex 2.13 syntax except that
;;;   the special characters !, @, |, ", and \ are freely allowed within
;;;   embeded {, } pairs in the "actual entry" portion of a level (the
;;;   portion following @, if any).  a modified version of makeindex 2.13
;;;   that supports this extension (with the -d [allow delimited special
;;;   chars] flag) is available here as well.


(eval-when (compile eval)
  (optimize-level 2)
  (case-sensitive #t))

(let ()
(include "dsm.ss")
(let ()
(include "preplib.ss")

(define tex-file-name
  (lambda (fn)
    (if (or (string=? (format "~a.tex" (file-name-root fn)) fn)
            (file-exists? fn))
        fn
        (format "~a.tex" fn))))

(define open-html-file
  (lambda (ip title)
    (define next-count
      (lambda (root)
        (cond
          [(assoc root output-file-counters) =>
           (lambda (a)
             (let ((n (+ (cdr a) 1)))
               (set-cdr! a n)
               n))]
          [else
           (set! output-file-counters
             (cons (cons root 0) output-file-counters))
           0])))
   ; generate sequence of names foo.html, foo_1.html, foo_2.html, ...
    (let ((op (let ((fn (let ((root (file-name-root (port-name current-ifile))))
                          (let ((n (next-count root)))
                            (if (= n 0)
                                (format "~a.html" root)
                                (format "~a_~d.html" root n))))))
                (open-output-file fn 'truncate))))
      (fprintf op "<!-- DO NOT EDIT THIS FILE-->~%")
      (fprintf op "<!-- Edit the .tex version instead-->~%~%")
      (fprintf op "<html>~%")
      (fprintf op "<head>~%<title>~a</title>~%</head>~%" title)
      (if body-format
          (fprintf op "<body ~a>" body-format)
          (fprintf op "<body>~%"))
      op)))

(define close-html-port
  (lambda (p)
    (fprintf p "</body>~%")
    (fprintf p "</html>~%")
    (close-output-port p)))

(define get-cite
  (lambda (key)
    (or (getprop key 'cite)
        (begin
           (warningf #f "bib entry ~a not found" key)
           "???"))))

(define put-label!
  (lambda (name type value)
    (putprop name type value)))

(define get-label
  (lambda (name type)
    (or (getprop name type)
        (begin
          (warningf #f "label (~a) ~a undefined" type name)
          "???"))))

(define read-aux-file
  (lambda (fn)
    (let ((ip (open-input-file fn)))
      (fluid-let ((current-ifile ip))
        (let loop ((newline? #f))
          (state-case (c (read-char ip))
            [(#\newline) (loop #t)]
            [(#\\)
             (when newline?
               (let ((cmd (read-command ip)))
                 (case cmd
                   [(|@|)
                    (let ((cmd (read-command ip)))
                      (case cmd
                        [(input)
                         (read-aux-file (read-bracketed-text ip))]))]
                   [(bibcite)
                    (let* ((key (read-bracketed-text ip))
                           (cite (read-bracketed-text ip)))
                      (putprop (string->symbol key) 'cite cite))]
                   [(newlabel)
                    (let* ((name (read-bracketed-text ip))
                           (ref (begin (read-open-brace ip)
                                       (read-bracketed-text ip)))
                           (pageref (read-bracketed-text ip)))
                      (put-label! (string->symbol name) 'pageref pageref))])))
             (loop #f)]
            [(eof) (void)]
            [else (loop #f)]))))))

;; structures
(define-structure (index-entry url keys texts pageno pageformat))

(define s$
  (lambda (ip op) ; within $...$
    (let ((s (let ((buf (open-output-string)))
               (let loop ()
                 (state-case (c (read-char ip))
                   [(#\$) (get-output-string buf)]
                   [(eof) (input-error "unexpected eof within $ ... $")]
                   [else (write-char c buf) (loop)])))))
      (emit-math s op))))

(define (scomment ip op hard-spaces)
  (state-case (c (read-char ip))
    [(eof #\newline)
     (unless hard-spaces
       (let eat-spaces ()
         (state-case (c (peek-char ip))
           [(#\space #\tab) (read-char ip) (eat-spaces)]
           [else (void)])))]
    [else (scomment ip op hard-spaces)]))

(define seqnarray*
  (lambda (ip op) ; within \begin{eqnarray*} ... \end{eqnarray*}
    (let ((s (let ((buf (open-output-string)))
               (let loop ()
                 (state-case (c (read-char ip))
                   [(#\\)
                    (let ((cmd (read-command ip)))
                      (case cmd
                        [(end)
                         (read-open-brace ip)
                         (if (equal? (read-bracketed-text ip 1) "eqnarray*")
                             (get-output-string buf)
                             (input-error "expected \\end{eqnarray*}"))]
                        [else
                         (fprintf buf "\\~a" cmd)
                         (loop)]))]
                   [(eof) (input-error "unexpected eof within eqnarray*")]
                   [else (write-char c buf) (loop)])))))
      (punt-to-latex (format "\\begin{eqnarray*}~a\\end{eqnarray*}" s) op))))

(define smathdisplay
  (lambda (ip op) ; within \[ ... \]
    (let ((s (let ((buf (open-output-string)))
               (let loop ()
                 (state-case (c (read-char ip))
                   [(#\\)
                    (let ((cmd (read-command ip)))
                      (case cmd ;[
                        [(|]|) (get-output-string buf)]
                        [else
                         (fprintf buf "\\~a" cmd)
                         (loop)]))]
                   [(eof) (input-error "unexpected eof within \\[ ... \\]")]
                   [else (write-char c buf) (loop)])))))
      (emit-math s op))))

(define emit-math
  (lambda (s op)
    (cond
      [(htmlmath (open-input-string s)) =>
       (lambda (html) (display html op))]
      [else (punt-to-latex (format "$~a$" s) op)])))

(define htmlmath
  (lambda (ip)
    (let ((buf (open-output-string)))
      (let loop ((closers '()))
        (state-case (c (read-char ip))
          [(#\\)
           (let ((cmd (read-command ip)))
             (case cmd
               [(|{| |}|)
                (fprintf buf "~a" cmd)
                (loop closers)]
               [(|,| |;|)
                (loop closers)]
               [(dots)
                (fprintf buf "...")
                (loop closers)]
               [(log)
                (fprintf buf "log")
                (loop closers)]
               [(pm)
                (fprintf buf "&plusmn;")
                (loop closers)]
               [(times)
                (fprintf buf " &times; ")
                (loop closers)]
               [else #f]))]
          [(#\{) (loop (cons "" closers))]
          [(#\}) (display (car closers) buf) (loop (cdr closers))]
          [(#\_)
           (state-case (c (read-char ip))
             [(#\{) #f]
             [(eof) (input-error "unexpected eof in math after _")]
             [else (fprintf buf "<sub>~a</sub>" c) (loop closers)])]
          [(#\^)
           (state-case (c (read-char ip))
             [(#\{) #f]
             [(eof) (input-error "unexpected eof in math after ^")]
             [else (fprintf buf "<sup>~a</sup>" c) (loop closers)])]
          [((#\a - #\z) (#\A - #\Z))
           (fprintf buf "<i>")
           (let loop ((c c))
             (write-char c buf)
             (state-case (c (peek-char ip))
               [((#\a - #\z) (#\A - #\Z)) (read-char ip) (loop c)]
               [else (void)]))
           (fprintf buf "</i>")
           (loop closers)]
          [(#\<) (fprintf buf " &lt; ") (loop closers)]
          [(#\>) (fprintf buf " &gt; ") (loop closers)]
          [(#\= #\+ #\-) (fprintf buf " ~c " c) (loop closers)]
          [((#\0 - #\9) #\space #\newline #\/ #\. #\( #\) #\[ #\] #\! #\| #\,)
           (write-char c buf) (loop closers)]
          [(eof) (get-output-string buf)]
          [else (input-error "unexpected character ~s in math mode" c)])))))

(define punt-to-latex
  (lambda (s op)
    (define latex-header
"\\documentclass[12pt]{article}
\\begin{document}
\\pagestyle{empty}
\\input mathmacros
")
    (define latex-trailer
"
\\end{document}
")
    (cond
      [(assoc s latex-cache) =>
       (lambda (a)
         (fprintf op "<img src=\"~a\">" (cdr a)))]
      [else
       (let* ((fn (math-file-name))
              (texfn (format "~a.tex" fn))
              (giffn (format "~a.gif" fn)))
         (fprintf op "<img src=\"~a\">" giffn)
         (set! latex-cache (cons (cons s (format "~a" giffn)) latex-cache))
        ; don't rewrite file unless different to avoid need to remake gif file
         (let ((s (format "~a~a~a" latex-header s latex-trailer)))
           (unless (guard (c [#t #f])
                     (let ((texip (open-input-file texfn)))
                       (let* ((n (string-length s)) (s1 (make-string n)))
                         (and (= (block-read texip s1 n) n)
                              (eof-object? (read-char texip))
                              (string=? s1 s)))))
             (let ((texop (open-output-file texfn 'truncate)))
               (display s texop)
               (close-output-port texop)))))])))

(define haux-put-label
  (lambda (label type url)
    (when haux-op
      (write `(putprop ',label ',type ,url) haux-op)
      (newline haux-op))))

(define current-ofile-name
  (lambda ()
    (if current-ofile
        (port-name current-ofile)
        "nofile")))

(define slabel
  (lambda (label text)
    (let ((tag (gensym)))
      (let ((url (format "~a#~a" (current-ofile-name) tag)))
        (haux-put-label label 'pageref-url url)
        (when current-ref-label
          (haux-put-label label 'ref (car current-ref-label))
          (haux-put-label label 'ref-url (cdr current-ref-label))))
      (format "<a name=\"~a\">~a</a>" tag text))))

(define sindex
  ; 1. read contents of \index{} form
  ;    separate at !s into 1 or more levels plus page format after |, if
  ;    present; separate levels at @ into sort key and text, if present
  ;    recognize quoted/escaped characters in the input
  ; 2. look up pageno & url corresponding
  ; 3. cons entry on to index-entries
  (lambda (ip op lab)
    (call-with-values
      (lambda () (parse-index ip #f))
      (lambda (levels page-format)
        (let ((keys (map (lambda (level) (or (car level) (cdr level)))
                         levels))
              (texts (map cdr levels))
              (pageno (get-label lab 'pageref))
              (url (get-label lab 'pageref-url)))
          (set! index-entries
            (cons (make-index-entry url keys texts pageno page-format)
                  index-entries)))))))
    
(define smakeindex
 ; insert indexspace between letters?
 ; links per starting letter?
  (lambda (op)
    (define print-page
      (lambda (entry)
        (let ((pageno (format "\\raw{<a href=\"~a\">}~a\\raw{</a>}"
                        (index-entry-url entry)
                        (index-entry-pageno entry)))
              (pageformat (index-entry-pageformat entry)))
          (if (string=? pageformat "")
              (fprintf op ", ~a" pageno)
              (fprintf op ", \\~a{~a}" pageformat pageno)))))
     (define print-item
       (lambda (entry inkeys level)
         (let f ((keys (index-entry-keys entry))
                 (texts (index-entry-texts entry)))
           (if (eq? keys inkeys)
               (let f ((texts texts) (level level))
                 (if (null? texts)
                     (print-page entry)
                     (begin
                       (fprintf op "~%\\")
                       (do ((i level (- i 1))) ((= i 0)) (display "sub" op))
                       (fprintf op "item ~a" (car texts))
                       (f (cdr texts) (+ level 1)))))
               (f (cdr keys) (cdr texts))))))
    (fprintf op "\\begin{theindex}~%")
    (let ((ls (sort (lambda (x y)
                      (let f ((xkeys (index-entry-keys x))
                              (ykeys (index-entry-keys y)))
                        (cond
                          [(null? xkeys)
                           (or (not (null? ykeys))
                               (< (pageno->number (index-entry-pageno x))
                                  (pageno->number (index-entry-pageno y))))]
                          [(null? ykeys) #f]
                          [else
                           (case (key-cmp (car xkeys) (car ykeys))
                             [(<) #t]
                             [(>) #f]
                             [else (f (cdr xkeys) (cdr ykeys))])])))
                    index-entries)))
      (let loop ((ls ls) (last-keys '()))
        (unless (null? ls)
          (let* ((entry (car ls)) (keys (index-entry-keys entry)))
            (let f ((keys keys) (last-keys last-keys) (level 0))
              (if (null? last-keys)
                  (if (null? keys)
                      (print-page entry)
                      (print-item entry keys level))
                  (if (eq? (key-cmp (car keys) (car last-keys)) '=)
                      (f (cdr keys) (cdr last-keys) (+ level 1))
                      (print-item entry keys level))))
            (loop (cdr ls) keys)))))
    (fprintf op "\\end{theindex}~%")))

(define pageno->number
  (lambda (s)
    (let ((sip (open-input-string s)))
      (let loop ((a -10000))
        (state-case (c (read-char sip))
          [(#\i)
           (state-case (c (peek-char sip))
             [(#\v) (read-char sip) (loop (+ a 4))]
             [(#\x) (read-char sip) (loop (+ a 9))]
             [else (loop (+ a 1))])]
          [(#\v)
           (state-case (c (peek-char sip))
             [(#\x) (read-char sip) (loop (+ a 5))]
             [else (loop (+ a 5))])]
          [(#\x) (loop (+ a 10))]
          [(eof) a]
          [else (or (string->number s) -1)])))))

(define char-table
  (let ((s (make-string 256 #\nul)))
    (define fill!
      (lambda (i ls)
        (unless (null? ls)
          (for-each
            (lambda (c) (string-set! s (char->integer c) (integer->char i)))
            (if (char? (car ls)) (list (car ls)) (car ls)))
          (fill! (+ i 1) (cdr ls)))))
    (fill! 1 '(
       #\! #\" #\# #\$ #\% #\& #\' #\( #\) #\* #\+ #\, #\- #\.  #\/ #\:
       #\; #\< #\= #\> #\? #\@ #\[ #\\ #\] #\^ #\_ #\` #\{ #\| #\} #\~
       #\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9
       (#\A #\a) (#\B #\b) (#\C #\c) (#\D #\d) (#\E #\e) (#\F #\f)
       (#\G #\g) (#\H #\h) (#\I #\i) (#\J #\j) (#\K #\k) (#\L #\l)
       (#\M #\m) (#\N #\n) (#\O #\o) (#\P #\p) (#\Q #\q) (#\R #\r)
       (#\S #\s) (#\T #\t) (#\U #\u) (#\V #\v) (#\W #\w) (#\X #\x)
       (#\Y #\y) (#\Z #\z)))
    s))

(define char-cvt
 ; place all non-alphabetic characters up front; commonize upper and
 ; lower case characters
  (lambda (c)
    (string-ref char-table (char->integer c))))

(define key-cmp
  ; returns <, =, > if x<y, =y, >y
  (lambda (s1 s2)
    (let ([n1 (string-length s1)] [n2 (string-length s2)])
      (let f ([i 0])
        (if (fx= i n2)
            (if (fx= i n1) '= '>)
            (if (fx= i n1)
                '<
                (let ([c1 (char-cvt (string-ref s1 i))]
                      [c2 (char-cvt (string-ref s2 i))])
                  (if (char<? c1 c2)
                      '<
                      (if (char=? c1 c2) (f (fx+ i 1)) '>)))))))))

(define push-undo
  (lambda (p undos)
    (cons (cons p (car undos)) (cdr undos))))

;(make-undefined ip op def-env pending groups ips ops ifiles
;   ofiles eofconts undos)

(define-syntactic-monad P
  ip                   ; current input port
  op                   ; current output port
  def-env              ; definition environment
  pending              ; stack of pending latex "environments"
  groups               ; stack of pending groups
  ips                  ; input port stack; does not include ip
  ops                  ; output port stack; does not include op
  ifiles               ; stack of input files [(cons ip ips) w/o string ports]
  ofiles               ; stack of output files [(cons op ops) w/o string ports]
  hard-spaces          ; if #t, treat spaces as ~
  eofconts             ; stack of continuations to call on eof
  undos                ; stack of lists of undo procs to call when group ends
)

(define sinclude
  (P lambda (fn)
    (let ((new-ip
           (guard (c [#t (warningf #f "cannot open ~a" fn) #f])
             (open-input-file fn))))
      (if new-ip
          (P s0
            ([ip new-ip]
             [ips (cons ip ips)]
             [eofconts (cons s0 eofconts)]
             [ifiles (push-ifile new-ip ifiles)]))
          (P s0)))))

(define sbegingroup
  (P lambda (g)
    (P s0
      ([groups (cons g groups)]
       [def-env (cons '() def-env)]
       [undos (cons '() undos)]))))

(define sundo
  (lambda (ls)
    (if (null? ls)
        s0
        (P lambda ()
          (P (car ls) () (sundo (cdr ls)))))))

(define sendgroup
  (P lambda (g)
    (unless (eq? (car groups) g)
      (input-error "unmatched ~a"
        (if (eq? g 'bgroup) "close brace or egroup" "endgroup")))
    (P (sundo (car undos))
      ([groups (cdr groups)]
       [def-env (cdr def-env)]
       [undos (cdr undos)]))))
      
(define snewcommand
  (P lambda (cmd)
    (define iota
      (lambda (i n)
        (if (> i n) '() (cons i (iota (+ i 1) n)))))
    (let* ((argcnt-str (read-optional-arg ip))
           (argcnt (if argcnt-str (string->number argcnt-str) 0))
           (opt (read-optional-arg ip))
           (template (read-bracketed-text ip)))
      (unless (and argcnt (<= (if opt 1 0) argcnt 9))
        (input-error "invalid argument count ~a" argcnt-str))
      (let ((pattern (if opt (cons opt (iota 2 argcnt)) (iota 1 argcnt))))
        (set-def! cmd def-env #f
          (P lambda ()
            (P s0
              ([ip (open-input-string
                     (expand-template template
                       (read-args ip pattern cmd) cmd))]
               [ips (cons ip ips)]
               [eofconts (cons s0 eofconts)]))))))
    (P s0)))

(define snewenvironment
  (P lambda (cmd)
    (define iota
      (lambda (i n)
        (if (> i n) '() (cons i (iota (+ i 1) n)))))
    (let* ((argcnt-str (read-optional-arg ip))
           (argcnt (if argcnt-str (string->number argcnt-str) 0))
           (opt (read-optional-arg ip))
           (b (begin (suppress-white-space ip) (read-bracketed-text ip)))
           (e (begin (suppress-white-space ip) (read-bracketed-text ip))))
      (unless (and argcnt (<= (if opt 1 0) argcnt 9))
        (input-error "invalid argument count ~a" argcnt-str))
      (let ((pattern (if opt (cons opt (iota 2 argcnt)) (iota 1 argcnt))))
        (set-def! cmd def-env #f
          (P lambda ()
            (P s0
              ([ip (open-input-string
                     (expand-template b
                       (read-args ip pattern cmd) cmd))]
               [ips (cons ip ips)]
               [eofconts (cons s0 eofconts)])))))
      (let ((endcmd (string->symbol (format "end~a" cmd))))
        (set-def! endcmd def-env #f
          (P lambda ()
            (P s0 ([ip (open-input-string e)]
                   [ips (cons ip ips)]
                   [eofconts (cons s0 eofconts)]))))))
    (P s0)))

(define process-string
  (P lambda (s k)
    (P s0
      ([ip (open-input-string s)]
       [ips (cons ip ips)]
       [eofconts (cons (P lambda ()
                         (P k
                           ([op (car ops)] [ops (cdr ops)])
                           (get-output-string op)))
                       eofconts)]
       [op (open-output-string)]
       [ops (cons op ops)]))))

(define new-conditional
  (lambda (ifcmd def-env default cmdtrue cmdfalse)
    (define scan-if
      (let ((buf (open-output-string)))
        (lambda (ip def-env hard-spaces)
          (let loop ((depth 0) (then-part #f))
            (state-case (c (read-char ip))
              [(#\\)
               (let ((cmd (read-command ip)))
                 (cond
                   [(conditional? cmd def-env)
                    (fprintf buf "\\~a" cmd)
                    (loop (+ depth 1) then-part)]
                   [(and (= depth 0) (eq? cmd 'else))
                    (if then-part
                        (input-error "extra \\else found")
                        (loop depth (get-output-string buf)))]
                   [(eq? cmd 'fi)
                    (if (= depth 0)
                        (if then-part
                            (values then-part (get-output-string buf))
                            (values (get-output-string buf) ""))
                        (begin
                          (fprintf buf "\\~a" cmd)
                          (loop (- depth 1) then-part)))]
                   [else
                    (fprintf buf "\\~a" cmd)
                    (loop depth then-part)]))]
              [(#\%)
               (scomment ip buf hard-spaces)
               (loop depth then-part)]
              [(#\{)
               (fprintf buf "{~a}" (read-bracketed-text ip 1))
               (loop depth then-part)]
              [(#\}) (input-error "unmatched } within \\if ... \\fi")]
              [(eof) (input-error
                       "unexpected end-of-file within \\if ... \\fi")]
              [else (write-char c buf) (loop depth then-part)])))))
    (let ((cell (cons default (void))))
      (set-def! ifcmd def-env #t
        (P lambda ()
          (call-with-values
            (lambda () (scan-if ip def-env hard-spaces))
            (lambda (then-part else-part)
              (let ((part (if (car cell) then-part else-part)))
                (P s0 ([ip (open-input-string part)]
                       [ips (cons ip ips)]
                       [eofconts (cons s0 eofconts)])))))))
      (when cmdtrue
        (set-def! cmdtrue def-env #f
          (P lambda ()
            (set-car! cell #t)
            (P s0))))
      (when cmdfalse
        (set-def! cmdfalse def-env #f
          (P lambda ()
            (set-car! cell #f)
            (P s0)))))))

(define snewif
  (lambda (ip def-env)
    (state-case (c (read-char ip))
      [(#\\)
       (let ((ifcmd (read-command ip)))
         (let ((ifcmd-str (symbol->string ifcmd)))
           (unless (and (> (string-length ifcmd-str) 2)
                        (string=? (substring ifcmd-str 0 2) "if"))
             (input-error "invalid conditional name ~a" ifcmd))
           (let ((cmd (substring ifcmd-str 2 (string-length ifcmd-str))))
             (new-conditional ifcmd def-env #f
               (string->symbol (string-append cmd "true"))
               (string->symbol (string-append cmd "false"))))))]
      [else (input-error "unexpected character following \\newif")])))

(define-syntax numbering-command
  (syntax-rules ()
    [(_ who fmt)
     (global-def who (snumber 'who fmt))]))

(define snumber
  (lambda (who fmt)
    (P lambda ()
      (let* ((counter (string->symbol (read-bracketed-text ip)))
             (value (get-counter-value counter)))
        (unless value
          (input-error "unknown counter in \\~a{~a}" who counter))
        (display (fmt (get-counter-value counter)) op))
      (P s0))))

(define s0
  (P lambda ()
    (state-case (c (read-char ip))
      [(#\\)
       (let ((cmd (read-command ip)))
         (cond
           [(get-def cmd def-env) =>
            (lambda (proc)
              (unless (command-symbol? cmd)
                (if hard-spaces
                    (let loop () ; squeeze out only empty lines
                      (state-case (c (peek-char ip))
                        [(#\newline) (read-char ip) (loop)]
                        [(#\%) (read-char ip) (scomment ip op hard-spaces) (loop)]
                        [else (void)]))
                    (suppress-white-space ip)))
              (P proc))]
           [else (unexpected-command cmd)]))]
      [(#\space #\tab)
       (if hard-spaces (display "&nbsp;" op) (write-char c op))
       (P s0)]
      [(#\~)
       (display "&nbsp;" op)
       (P s0)]
      [(#\<) (fprintf op "&lt;") (P s0)]
      [(#\>) (fprintf op "&gt;") (P s0)]
      [(#\$)
       (s$ ip op)
       (P s0)]
      [(#\%) (scomment ip op hard-spaces) (P s0)]
      [(#\{) (P sbegingroup () 'group)]
      [(#\}) (P sendgroup () 'group)]
      [(#\` #\')
       (if (eqv? (peek-char ip) c)
           (begin (read-char ip) (write-char #\" op))
           (write-char c op))
       (P s0)]
      [(#\newline)
       (write-char c op)
       (when (let loop ((par? #f)) ; insert par for multiple blank lines
               (state-case (c (peek-char ip))
                 [(#\newline) (read-char ip) (write-char c op) (loop #t)]
                 [(#\space #\tab)
                  (if hard-spaces
                      par?
                      (begin (read-char ip) (write-char c op) (loop par?)))]
                 [(#\%) (read-char ip) (scomment ip op hard-spaces) (loop par?)]
                 [else par?]))
         (fprintf op "<p>~%"))
       (P s0)]
      [(eof)
       (close-input-port ip)
       (if (null? ips)
           (void)
           (P (car eofconts)
             ([ip (car ips)]
              [ips (cdr ips)]
              [ifiles (if (eq? ip (car ifiles)) (pop-ifile ifiles) ifiles)]
              [eofconts (cdr eofconts)])))]
      [else (write-char c op) (P s0)])))

;;; global constants
(define genlab-prefix "h")  ; unique string for this processor

;;; global variables
(define body-format)
(define current-entry-label) ; set to (pageno . url) by entryheader
(define current-ifile) ; for genlab, input-error, open-html-file
(define current-ofile) ; for slabel
(define current-ref-label)
(define document-title)
(define index-entries)
(define genlab-counters)
(define latex-cache)
(define output-file-counters)
(define haux-op)

(set! go
  (lambda (fn)
    (let ((ip (open-input-file (tex-file-name fn))))
      (fluid-let ((body-format #f)
                  (current-entry-label #f)
                  (current-ifile #f)
                  (current-ofile #f)
                  (current-ref-label #f)
                  (document-title "Untitled Document")
                  (index-entries '())
                  (genlab-counters '())
                  (latex-cache '())
                  (output-file-counters '())
                  (haux-op #f))
        (P s0
          ([ip ip]
           [op (open-output-string)]
           [def-env '()]
           [pending '(top)]
           [groups '(top)]
           [ips '()]
           [ops '()]
           [ifiles (push-ifile ip '())]
           [ofiles '()]
           [hard-spaces #f]
           [eofconts (list s0)]
           [undos (list '())]))))))

(global-def def
  (P lambda ()
    (let* ((cmd (state-case (c (read-char ip))
                  [(#\\) (read-command ip)]
                  [else (input-error "invalid \\def syntax")]))
           (pattern (read-def-pattern ip))
           (template (read-bracketed-text ip)))
      (set-def! cmd def-env #f
        (P lambda ()
          (P s0
            ([ip (open-input-string
                   (expand-template template
                     (read-args ip pattern cmd) cmd))]
             [ips (cons ip ips)]
             [eofconts (cons s0 eofconts)]))))
      (P s0))))

(global-def edef
  (P lambda ()
    (let* ((cmd (state-case (c (read-char ip))
                  [(#\\) (read-command ip)]
                  [else (input-error "invalid \\def syntax")]))
           (pattern (read-def-pattern ip))
           (template (read-bracketed-text ip)))
      (P process-string () template
        (P lambda (template)
          (set-def! cmd def-env #f
            (P lambda ()
              (P s0
                ([ip (open-input-string
                       (expand-template template
                         (read-args ip pattern cmd) cmd))]
                 [ips (cons ip ips)]
                 [eofconts (cons s0 eofconts)]))))
          (P s0))))))

(global-def newcommand
  (P lambda ()
    (read-open-brace ip)
    (read-back-slash ip)
    (let* ((cmd (read-command ip)))
      (read-close-brace ip)
      (when (get-def cmd def-env)
        (input-error "\\newcommand: \\~a already defined" cmd))
      (P snewcommand () cmd))))

(global-def renewcommand
  (P lambda ()
    (read-open-brace ip)
    (read-back-slash ip)
    (let* ((cmd (read-command ip)))
      (read-close-brace ip)
      (unless (get-def cmd def-env)
        (input-error "\\renewcommand: \\~a undefined" cmd))
      (P snewcommand () cmd))))

(global-def newenvironment
  (P lambda ()
    (let* ((cmd (string->symbol (read-bracketed-text ip))))
      (when (get-def cmd def-env)
        (input-error "\\newenvironment: \\~a already defined" cmd))
      (P snewenvironment () cmd))))

(global-def renewenvironment
  (P lambda ()
    (let* ((cmd (string->symbol (read-bracketed-text ip))))
      (unless (get-def cmd def-env)
        (input-error "\\renewenvironment: \\~a undefined" cmd))
      (P snewenvironment () cmd))))

(global-def begin
  (P lambda ()
    (let ((cmd (string->symbol (read-bracketed-text ip))))
      (cond
        [(get-def cmd def-env) =>
           (lambda (proc) (P proc ([pending (cons cmd pending)])))]
        [else (input-error "undefined command \\begin{~a}" cmd)]))))

(global-def end
  (P lambda ()
    (let* ((cmd (string->symbol (read-bracketed-text ip)))
           (endcmd (string->symbol (format "end~a" cmd))))
      (unless (eq? (car pending) cmd)
        (input-error "unmatched \\end{~a}" cmd))
      (cond
        [(get-def endcmd def-env) =>
           (lambda (proc) (P proc ([pending (cdr pending)])))]
        [else (input-error "undefined command \\end{~a}" cmd)]))))

(global-def eqnarray* ; no endeqnarray*---we finish the job here
  (P lambda ()
    (fprintf op "<p>~%")
    (seqnarray* ip op)
    (fprintf op "<p>~%")
    (P s0 ([pending (cdr pending)]))))

(global-def divertoutput
  (P lambda ()
    (let* ((level-str (or (read-optional-arg ip) "0"))
           (level (let ((i (string->number level-str))
                        (n (length ofiles)))
                    (and (fixnum? i)
                         (if (fx< -1 i n)
                             (fx- n i 1)
                             (and (fx<= (- n) i -1)
                                  (fx- -1 i)))))))
      (unless level
        (input-error "invalid \\outputlevel level ~a" level-str))
      (P s0 ([op (list-ref ofiles level)] [ops (cons op ops)])))))

(global-def enddivertoutput
  (P lambda ()
    (P s0 ([op (car ops)] [ops (cdr ops)]))))

(global-def begingroup
  (P lambda ()
    (P sbegingroup () 'begingroup)))

(global-def endgroup
  (P lambda ()
    (P sendgroup () 'begingroup)))

(global-def bgroup
  (P lambda ()
    (P sbegingroup () 'bgroup)))

(global-def egroup
  (P lambda ()
    (P sendgroup () 'bgroup)))

(global-def |[| ;]
  (P lambda ()
    (fprintf op "<p>~%")
    (smathdisplay ip op)
    (fprintf op "<p>~%")
    (P s0)))

(global-def raw
  (P lambda ()
    (display (read-bracketed-text ip) op)
    (P s0)))

(global-def newif
  (P lambda ()
    (snewif ip def-env)
    (P s0)))

(numbering-command arabic (lambda (n) n))
(numbering-command alph
  (lambda (n)
    (when (> n 26)
      (input-error "counter value ~a too large for \\alph" n))
    (string-ref "abcdefghijklmnopqrstuvwxyz" (- n 1))))
(numbering-command Alph
  (lambda (n)
    (when (> n 26)
      (input-error "counter value ~a too large for \\Alph" n))
    (string-ref "ABCDEFGHIJKLMNOPQRSTUVWXYZ" (- n 1))))

(global-def newcounter
  (P lambda ()
    (let* ((name-str (read-bracketed-text ip))
           (counter (string->symbol name-str))
           (within (read-optional-arg ip)))
      (when (get-counter-value counter)
        (input-error "newcounter of existing counter ~a" counter))
      (when within
        (let ((within (string->symbol within)))
          (unless (get-counter-value within)
            (input-error "newcounter of ~a within unknown counter ~a"
              counter within))
          (add-subcounter! within counter)))
      (set-counter-value! counter 0)
      (set-def! (string->symbol (string-append "the" name-str)) def-env #f
        (P lambda ()
          (display (get-counter-value counter) op)
          (P s0))))
    (P s0)))

(global-def setcounter
  (P lambda ()
    (let* ((counter (string->symbol (read-bracketed-text ip)))
           (num-str (read-bracketed-text ip))
           (old-value (get-counter-value counter))
           (new-value (string->number num-str)))
      (unless old-value
        (input-error "setcounter of unknown counter ~a" counter))
      (unless new-value
        (input-error "invalid setcounter value ~a" num-str))
      (set-counter-value! counter new-value))
    (P s0)))

(global-def addtocounter
  (P lambda ()
    (let* ((counter (string->symbol (read-bracketed-text ip)))
           (num-str (read-bracketed-text ip))
           (old-value (get-counter-value counter))
           (incr (string->number num-str)))
      (unless old-value
        (input-error "addtocounter of unknown counter ~a" counter))
      (unless new-value
        (input-error "invalid addtocounter increment ~a" num-str))
      (set-counter-value! counter (+ old-value incr)))
    (P s0)))

(global-def stepcounter
  (P lambda ()
    (let* ((counter (string->symbol (read-bracketed-text ip)))
           (old-value (get-counter-value counter)))
      (unless old-value
        (input-error "\\stepcounter of unknown counter ~a" counter))
      (set-counter-value! counter (+ old-value 1))
      (for-each
        (lambda (x) (set-counter-value! x 0))
        (subcounters counter)))
    (P s0)))

(global-def refstepcounter
  (P lambda ()
    (let* ((counter (string->symbol (read-bracketed-text ip)))
           (old-value (get-counter-value counter)))
      (unless old-value
        (input-error "\\refstepcounter of unknown counter ~a" counter))
      (set-counter-value! counter (+ old-value 1))
      (for-each
        (lambda (x) (set-counter-value! x 0))
        (subcounters counter))
      (P process-string () (format "\\the~a" counter)
        (P lambda (s)
          (let ((tag (gensym)))
            (set! current-ref-label
              (cons s (format "~a#~a" (current-ofile-name) tag)))
            (fprintf op "<a name=\"~a\"></a>" tag))
          (P s0))))))

(global-def pagebreak
  (P lambda ()
    (read-optional-arg ip) ; ignore [...]
    (P s0)))

(global-def var
  (P lambda ()
    (dovar ip op)
    (P s0)))

(global-def |'|
  (P lambda ()
    (state-case (c (read-char ip))
      [(#\e) (fprintf op "&eacute;")]
      [(#\o) (fprintf op "&oacute;")]
      [else (input-error "invalid \\' command \\'~a" c)])
    (P s0)))

(global-def |"|      ; \"{<letter>}
  (P lambda ()
    (let ([arg (read-bracketed-text ip)])
      (unless (= (string-length arg) 1)
        (input-error "invalid \\\" argument ~s" arg))
      (case (string-ref arg 0)
        [(#\a #\e #\i #\o #\u #\y #\A #\E #\I #\O #\U)
         (fprintf op "&~auml;" (string-ref arg 0))]
        [else (input-error "invalid \\\" command \\\"{~a}" c)]))
    (P s0)))

(global-def |c|      ; \c{<letter>}
  (P lambda ()
    (let ([arg (read-bracketed-text ip)])
      (unless (= (string-length arg) 1)
        (input-error "invalid \\c argument ~s" arg))
      (case (string-ref arg 0)
        [(#\c #\C) (fprintf op "&~acedil;" (string-ref arg 0))]
        [else (input-error "invalid \\c command \\c{~a}" c)]))
    (P s0)))

(global-def vskip
  (P lambda ()
    ; it's a pain to parse tex amounts, so we choose to ignore
    ; everything up to the next line break instead...watch out!
    (let f ()
      (state-case (c (read-char ip))
        ((#\newline eof) (P s0))
        (else (f))))))

(global-def tt
  (P lambda ()
    (fprintf op "<tt>")
    (P s0
      ([undos (push-undo
                (P lambda (next) (fprintf op "</tt>") (P next))
                undos)]))))

(global-def bf
  (P lambda ()
    (fprintf op "<b>")
    (P s0
      ([undos (push-undo
                (P lambda (next) (fprintf op "</b>") (P next))
                undos)]))))

(global-def hardspaces
  (P lambda ()
    (let ((old-hs hard-spaces))
      (P s0
        ([hard-spaces #t]
         [undos (push-undo
                  (P lambda (next) (P next ([hard-spaces old-hs])))
                  undos)])))))

(global-def include
  (P lambda ()
    (P process-string () (read-bracketed-text ip)
      (P lambda (fn)
        (P sinclude () (tex-file-name fn))))))

(global-def input
  (P lambda ()
    (P process-string () (read-bracketed-text ip)
      (P lambda (fn)
        (P sinclude () (tex-file-name fn))))))

(global-def label
  (P lambda ()
    (P process-string () (read-bracketed-text ip)
      (P lambda (s)
        (display (slabel (string->symbol s) "") op)
        (P s0)))))

(global-def href
  (P lambda ()
    (P process-string () (read-bracketed-text ip)
      (P lambda (lab)
        (P process-string () (read-bracketed-text ip)
          (P lambda (text)
            (let ((name (string->symbol lab)))
              (fprintf op "<a href=\"~a\">~a</a>" (get-label name 'ref-url) text)
              (P s0))))))))

(global-def hpageref
  (P lambda ()
    (P process-string () (read-bracketed-text ip)
      (P lambda (lab)
        (P process-string () (read-bracketed-text ip)
          (P lambda (text)
            (let ((name (string->symbol lab)))
              (fprintf op "<a href=\"~a\">~a</a>" (get-label name 'pageref-url) text)
              (P s0))))))))

(global-def ref
  (P lambda ()
    (P process-string () (read-bracketed-text ip)
      (P lambda (s)
        (let ((name (string->symbol s)))
          (fprintf op "<a href=\"~a\">~a</a>"
            (get-label name 'ref-url)
            (get-label name 'ref)))
        (P s0)))))
       
(global-def pageref
  (P lambda ()
    (P process-string () (read-bracketed-text ip)
      (P lambda (s)
        (let ((name (string->symbol s)))
          (fprintf op "<a href=\"~a\">~a</a>"
            (get-label name 'pageref-url)
            (get-label name 'pageref)))
        (P s0)))))
       
(global-def cite
  (P lambda ()
    (write-char #\[ op)
    (let ((keys (let ((sip (open-input-string (read-bracketed-text ip)))
                      (buf (open-output-string)))
                  (let loop ()
                    (state-case (c (read-char sip))
                      [(#\,)
                       (let ((key (get-output-string buf)))
                         (cons key (loop)))]
                      [(eof)
                       (list (get-output-string buf))]
                      [else
                       (write-char c buf)
                       (loop)])))))
      (do ((keys keys (cdr keys)) (sep "" ","))
          ((null? keys) (write-char #\] op))
          (let ((key (string->symbol (car keys))))
            (fprintf op "~a<a href=\"~a\">~a</a>"
              sep (get-label key 'pageref-url) (get-cite key)))))
    (P s0)))

(global-def epsfbox
  (P lambda ()
    (fprintf op "<p>~%")
    (punt-to-latex (format "\\input{epsf.sty}\\epsfbox{~a}" (read-bracketed-text ip)) op)
    (fprintf op "<p>~%")
    (P s0)))

(global-def bibitem
  (P lambda ()
    (let ((key (string->symbol (read-bracketed-text ip))))
      (fprintf op "<p>[~a] " (slabel key (get-cite key))))
    (P s0)))

(global-def openhtmlfile
  (P lambda ()
    (P process-string () (read-bracketed-text ip)
      (P lambda (title)
        (let ((new-op (open-html-file (car ifiles) title)))
          (P s0
            ([op new-op]
             [ops (cons op ops)]
             [ofiles (push-ofile new-op ofiles)])))))))

(global-def closehtmlfile
  (P lambda ()
    (unless (and (not (null? ofiles)) (eq? op (car ofiles)))
      (input-error "invalid context for \\closehtmlfile"))
    (close-html-port op)
    (P s0 ([op (car ops)] [ops (cdr ops)] [ofiles (pop-ofile ofiles)]))))

(global-def genlab
  (P lambda ()
    (display (genlab) op)
    (P s0)))

(global-def hindex
  (P lambda ()
    (P process-string () (read-bracketed-text ip)
      (P lambda (s)
        (read-open-brace ip)
        (sindex ip op (string->symbol s))
        (P s0)))))

(global-def index
  (P lambda ()
    (let ((lab (genlab)))
      (display (slabel lab "") op)
      (read-open-brace ip)
      (sindex ip op lab)
      (P s0))))

(global-def makeindex
  (P lambda ()
    (let ((buf (open-output-string)))
      (smakeindex buf)
      (P s0 ([ip (open-input-string (get-output-string buf))]
             [ips (cons ip ips)]
             [eofconts (cons s0 eofconts)])))))

(global-def documentclass
  (P lambda ()
    (read-optional-arg ip)
    (P sinclude () (format "~a.hcls" (read-bracketed-text ip)))))

(global-def document
  (P lambda ()
    (let ((root (file-name-root (port-name (car ifiles)))))
      (let ((auxfn (format "~a.aux" root)) (hauxfn (format "~a.haux" root)))
        (guard (c [#t (warningf #f "missing or incomplete aux file")])
          (read-aux-file (format "~a.aux" root)))
        (guard (c [#t (warningf #f "missing or incomplete haux file")])
          (load hauxfn))
        (set! haux-op (open-output-file hauxfn 'truncate))))
    (P s0
      ([ip (open-input-string
             (format "\\openhtmlfile{\\raw{~a}}" document-title))]
       [ips (cons ip ips)]
       [eofconts (cons s0 eofconts)]))))

(global-def enddocument
  (P lambda ()
    (P s0
      ([ip (open-input-string "\\closehtmlfile")]
       [ips (cons ip ips)]
       [eofconts (cons s0 eofconts)]))))

(global-def documenttitle
  (P lambda ()
    (let ([fmt (read-optional-arg ip)])
      (P process-string () (read-bracketed-text ip)
        (P lambda (title)
          (set! body-format fmt)
          (set! document-title title)
          (P s0))))))

(global-def |{|
  (P lambda ()
    (display "{" op)
    (P s0)))

(global-def |}|
  (P lambda ()
    (display "}" op)
    (P s0)))
))

